---
title: redis面试题
abbrlink: 18435
date: 2022-04-07 13:36:49
tags:
---

# Redis

## 什么是redis 

redis 是一个 C 语言开发的，基于内存的，高性能 key-value 形式的，单线程的 NoSQL 数据库。可以用作数据库、缓存、消息中间件等，主要用于缓存和 session 共享。提高查询效率和用户体验，为分布式系统提供 session 共享。

Redis作为一个**非关系型**内存数据库

1. 性能优秀，数据在**内存中**，**读写速度非常快**，支持**并发10W QPS**；
2. **单进程单线程**，是**线程安全**的，采用**IO多路复用机制**；
3. 丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（**zset**）等；
4. 支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载；
5. 主从复制，哨兵，高可用；
6. 可以用作分布式锁；
7. 可以作为消息中间件使用，**支持发布订阅**

## Redis五种数据类型

![img](https://img-blog.csdnimg.cn/img_convert/648f7d3c9ae46ba1b9baa220f7caeaf8.png)

1. string是redis最基本的类型，可以理解成与memcached一模一样的类型，一个key对应一个value。value不仅是string，也可以是数字。string类型是二进制安全的，意思是redis的string类型可以包含任何数据，比如jpg图片或者序列化的对象。string类型的值最大能存储512M。
2. Hash是一个键值（key-value）的集合。redis的hash是一个string的key和value的映射表，Hash特别适合存储对象。常用命令：hget,hset,hgetall等。
3. list列表是简单的字符串列表，**按照插入顺序排序**。可以添加一个元素到列表的头部（左边）或者尾部（右边）  常用命令：lpush、rpush、lpop、rpop、lrange(获取列表片段)等。**应用场景：**list应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表都可以用list结构来实现。数据结构：list就是链表，可以用来当消息队列用。redis提供了List的push和pop操作，还提供了操作某一段的api，可以直接查询或者删除某一段的元素。**实现方式：**redis list的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销。
4. **set是string类型的无序集合**。集合是通过hashtable实现的。set中的元素是没有顺序的，而且是没有重复的。常用命令：sdd、spop、smembers、sunion等。应用场景：redis set对外提供的功能和list一样是一个列表，特殊之处在于**set是自动去重的**，而且set提供了判断某个成员是否在一个set集合中。
5. zset和set一样是string类型元素的集合，且不允许重复的元素。常用命令：zadd、zrange、zrem、zcard等。使用场景：sorted set可以通过用户额外提供一个优先级（score）的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set结构。和set相比，sorted set**关联了一个double类型权重的参数score**，使得集合中的元素能够按照score进行有序排列，redis正是通过score来为集合中的成员进行从小到大的排序。实现方式：Redis sorted set的内部使用**HashMap和跳跃表(skipList)**来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。

## 使用场景

- [x] 手写的RedisTemplate

![](https://s2.loli.net/2022/04/07/mRb6Lnh3IaiHufF.png)

## redis使用中的问题

### 缓存和数据库数据一致性问题

分布式环境下非常容易出现**缓存和数据库间数据一致性问题**，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。

因为**写和读是并发的**，**没法保证顺序**，如果删了缓存，还没有来得及写库，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。如果先写了库，再删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。 如果是redis集群，或者主从模式，写主读从，由于redis复制存在一定的**时间延迟**，也有可能导致数据不一致。

### 优化思路

#### 双删加超时

在写库前后都进行`redis.del(key)`操作，并且**设定合理的超时时间**。这样最差的情况是在超时时间内存在不一致，当然这种情况极其少见，可能的原因就是服务宕机。此种情况可以满足绝大多数需求。 当然这种策略要考虑redis和数据库主从同步的耗时，所以在第二次删除前最好休眠一定时间，比如500毫秒，这样毫无疑问又增加了写请求的耗时

#### 异步淘汰缓存

通过读取binlog的方式，异步淘汰缓存。

**![img](https://s2.loli.net/2022/04/08/YTdZN9fgnOqlv4y.png)**

好处：业务代码侵入性低，将缓存与数据库不一致的时间尽可能缩小。

### Redis缓存雪崩

我了解的，目前电商首页以及热点数据都会去做缓存，一般缓存都是定时任务去刷新，或者查不到之后去更新缓存的，定时任务刷新就有一个问题。举个栗子：如果首页所有Key的失效时间都是12小时，中午12点刷新的，我零点有个大促活动大量用户涌入，假设每秒6000个请求，本来缓存可以抗住每秒5000个请求，但是缓存中所有Key都失效了。此时6000个/秒的请求全部落在了数据库上，数据库必然扛不住，真实情况可能DBA都没反应过来直接挂了，此时，如果没什么特别的方案来处理，DBA很着急，重启数据库，但是数据库立马又被新流量给打死了。这就是我理解的缓存雪崩。

同一时间大面积失效，瞬间Redis跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的，你想想如果挂的是一个用户服务的库，那其他依赖他的库所有接口几乎都会报错，如果没做熔断等策略基本上就是瞬间挂一片的节奏，你怎么重启用户都会把你打挂，等你重启好的时候，用户早睡觉去了

#### 解决方法

处理缓存雪崩简单，在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。

```java
setRedis（key, value, time+Math.random()*10000）;
```

如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效。或者设置热点数据永不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就好了，不要设置过期时间），电商首页的数据也可以用这个操作，保险

## Redis缓存击穿、缓存穿透

### 缓存穿透

先说下缓存穿透吧，缓存穿透是指缓存和数据库中都没有的数据，而用户（黑客）不断发起请求，举个栗子：我们数据库的id都是从1自增的，如果发起id=-1的数据或者id特别大不存在的数据，这样的不断攻击导致数据库压力很大，严重会击垮数据库。

### 缓存击穿

至于缓存击穿嘛，这个跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是缓存击穿是指一个Key非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发直接落到了数据库上，就在这个Key的点上击穿了缓存

## 解决方法

缓存穿透我会在接口层增加校验，比如用户鉴权，参数做校验，不合法的校验直接return，比如id做基础校验，id<=0直接拦截

我记得Redis里还有一个高级用法**布隆过滤器（Bloom Filter）** 这个也能很好的预防缓存穿透的发生，他的原理也很简单，就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查DB刷新KV再return。

缓存击穿的话，设置热点数据永不过期，或者加上互斥锁就搞定了。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。.

## redis为什么这么快

官方提供的数据可以达到**100000+的QPS**（每秒内的查询次数）

Redis是**单进程单线程的模型**，因为Redis完全是**基于内存**的操作，**CPU不是Redis的瓶颈**，Redis的瓶颈最有可能是**机器内存的大小或者网络带宽**。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章的采用单线程的方案了（毕竟采用多线程会有很多麻烦）。

1. Redis完全基于内存，绝大部分请求是纯粹的**内存操作**，非常迅速，数据存在内存中，**类似于HashMap**，HashMap的优势就是查找和操作的时间复杂度是O(1)。
2. **数据结构简单**，对数据操作也简单。
3. 采用**单线程**，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。
4. 使用**多路复用IO模型**，非阻塞IO。

## Redis和Memcached的区别

1. **存储方式上：**memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。***redis有部分数据存在硬盘上，这样能保证数据的持久性。***
2. **数据支持类型上：**memcache对数据类型的支持简单，只支持简单的key-value，，而***redis支持五种数据类型***。
3. **使用底层模型不同：**它们之间底层实现方式以及与客户端之间通信的应用协议不一样。***redis直接自己构建了VM机制***，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
4. **value的大小：**redis可以达到**1GB**，而memcache只有**1MB**。



## redis淘汰策略

| 策略            | 描述                                                         |
| :-------------- | :----------------------------------------------------------- |
| volatile-lru    | 从已设置过期时间的KV集中优先对最近**最少使用**(less recently used)的数据淘汰 |
| volitile-ttl    | 从已设置过期时间的KV集中优先对**剩余时间短**(time to live)的数据淘汰 |
| volitile-random | 从已设置过期时间的KV集中**随机选择**数据淘汰                 |
| allkeys-lru     | 从**所有KV集中优先对最近最少使用**(less recently used)的数据淘汰 |
| allKeys-random  | 从**所有KV集中随机**选择数据淘汰                             |
| noeviction      | 不淘汰策略，若超过最大内存，返回错误信息                     |

补充一下：Redis4.0加入了LFU(least frequency use)淘汰策略，包括volatile-lfu和allkeys-lfu，通过统计访问频率，将访问频率最少，即最不经常使用的KV淘汰。

## redis持久化

redis为了保证效率，**数据缓存在了内存中**，但是会**周期性**的把更新的数据**写入磁盘**或者把修改操作写入追加的记录文件中，**以保证数据的持久化**。

Redis的持久化策略有两种

1. **RDB：**快照形式是**直接把内存中的数据保存到一个dump的文件**中，定时保存，保存策略。
2. **AOF：**把**所有的对Redis的服务器进行修改的命令都存到一个文件里**，命令的集合。

Redis默认是快照RDB的持久化方式。当Redis重启的时候，它会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存储。

### RDB是怎么工作的

默认Redis是会以快照"RDB"的形式将数据持久化到磁盘的一个二进制文件dump.rdb。工作原理简单说一下：当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉，这样的好处是可以copy-on-write。

RDB的优点是：这种文件非常适合用于备份：比如，你可以在最近的24小时内，每小时备份一次，并且在每个月的每一天也备份一个RDB文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB非常适合灾难恢复。RDB的缺点是：如果你需要尽量避免在服务器故障时丢失数据，那么RDB不合适你。

### AOF是怎么工作的

每一个写命令都通过write函数追加到appendonly.aof中，配置方式如下：

```go
appendfsync yes   appendfsync always     #每次有数据修改发生时都会写入AOF文件。appendfsync everysec   #每秒钟同步一次，该策略为AOF的缺省策略。复制代码
```

AOF可以做到全程持久化，只需要在配置中开启 appendonly yes。这样redis每执行一个修改数据的命令，都会把它添加到AOF文件中，当redis重启时，将会读取AOF文件进行重放，恢复到redis关闭前的最后时刻。

使用AOF的优点是会让redis变得非常耐久。可以设置不同的fsync策略，aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB。

### 如何选择持久化策略

如果你非常关心你的数据，但仍然可以承受数分钟内的数据丢失，那么可以额只使用RDB持久。AOF将Redis执行的每一条命令追加到磁盘中，处理巨大的写入会降低Redis的性能，不知道你是否可以接受。数据库备份和灾难恢复：定时生成RDB快照非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度快。当然了，redis支持同时开启RDB和AOF，系统重启后，redis会优先使用AOF来恢复数据，这样丢失的数据会最少。

## 主从复制

> redis单节点存在单点故障问题，为了解决单点问题，一般都需要对redis配置从节点，然后使用哨兵来监听主节点的存活状态，如果主节点挂掉，从节点能继续提供缓存功能，你能说说redis主从复制的过程和原理吗？

主从配置结合哨兵模式能解决单点故障问题，提高redis可用性。从节点仅提供读操作，主节点提供写操作。对于读多写少的状况，可给主节点配置多个从节点，从而提高响应效率

1. 从节点执行`slaveof[masterIP][masterPort]`，保存主节点信息
2. 从节点中的定时任务发现主节点信息，建立和主节点的socket连接
3. 从节点发送Ping信号，主节点返回Pong，两边能互相通信
4. 连接建立后，主节点将所有数据发送给从节点（数据同步）
5. 主节点把当前的数据同步给从节点后，便完成了复制的建立过程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。



## 哨兵

> 那主从复制会存在哪些问题呢？

主从复制会存在以下问题：

1、一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。

2、主节点的写能力受到单机的限制。

3、主节点的存储能力受到单机的限制。

4、原生复制的弊端在早期的版本中也会比较突出，比如：redis复制中断后，从节点会发起psync。此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。

比较主流的解决方案是哨兵

![Redis Sentinel（哨兵）架构图](https://s2.loli.net/2022/04/07/yF5DZ3dQvGYTArK.jpg)

Redis Sentinel（哨兵）的架构图。Redis Sentinel（哨兵）主要功能包括**主节点存活检测**、**主从运行情况检测**、**自动故障转移**、**主从切换**。Redis Sentinel最小配置是一主一从。Redis的Sentinel系统可以用来管理多个Redis服务器，该系统可以执行以下四个任务：

1、监控：不断检查主服务器和从服务器是否正常运行。

2、通知：当被监控的某个redis服务器出现问题，Sentinel通过API脚本向管理员或者其他应用程序发出通知。

3、自动故障转移：当主节点不能正常工作时，Sentinel会开始一次自动的故障转移操作，它会将与失效主节点是主从关系的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点，这样人工干预就可以免了。

4、配置提供者：在Redis Sentinel模式下，客户端应用在初始化时连接的是Sentinel节点集合，从中获取主节点的信息。

### 哨兵的工作原理

用一个或者多个哨兵来监视主服务器(也就是进行写操作的服务器)是否在正常执行任务，一旦哨兵发现主服务器不可用时，就找到一个合适的从服务器成为主服务器。



